{"version":3,"sources":["webpack:///webpack/bootstrap 4d83cc4e85cc0ed39148","webpack:///./lib/util.js","webpack:///./lib/bullet.js","webpack:///./lib/moving_object.js","webpack:///./lib/tyranny.js","webpack:///./lib/game.js","webpack:///./lib/ship.js","webpack:///./lib/game_view.js","webpack:///./lib/tyran.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACrGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACZD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9KA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B,KAAK;AACL,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5EA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4d83cc4e85cc0ed39148","const Util = {\n  // Normalize the length of the vector to 1, maintaining direction.\n  dir (vec) {\n    var norm = Util.norm(vec);\n    return Util.scale(vec, 1 / norm);\n  },\n  // Find distance between two points.\n  dist (pos1, pos2) {\n    return Math.sqrt(\n      Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n    );\n  },\n  // Find the length of the vector.\n  norm (vec) {\n    return Util.dist([0, 0], vec);\n  },\n  // Return a randomly oriented vector with the given length.\n  randomVec (length) {\n    var deg = 2 * Math.PI * Math.random();\n    return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n  },\n  // Scale the length of a vector by the given amount.\n  scale (vec, m) {\n    return [vec[0] * m, vec[1] * m];\n  },\n  //This will help the wrapping of objects and will let cetain things go off screen and\n  //return back to the screen.\n  wrap (coord, max) {\n    if (coord < 0) {\n      return max - (coord % max);\n    } else if (coord > max) {\n      return coord % max;\n    } else {\n      return coord;\n    }\n  }\n};\n\nmodule.exports = Util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 0\n// module chunks = 0","const MovingObject = require(\"./moving_object\");\n\nclass Bullet extends MovingObject {\n  constructor(options) {\n    options.image = options.image;\n    options.type = options.type;\n    options.width = options.width;\n    options.height = options.height;\n    super(options);\n    //Everything else will be the same as moving object\n    //we don't want it to go offscreen and come back on screen.\n    this.isWrappable = false;\n  }\n}\n\nBullet.SPEED = 15;\n\nmodule.exports = Bullet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/bullet.js\n// module id = 1\n// module chunks = 0","const Util = require(\"./util\");\n\nclass MovingObject {\n  constructor(options) {\n    this.pos = options.pos;\n    this.width = options.width;\n    this.height = options.height;\n    this.vel = options.vel;\n    this.radius = options.radius;\n    this.color = options.color;\n    this.game = options.game;\n    this.image = options.image;\n    this.type = options.type;\n    //everything this wrappable except for bullets which are not.\n    this.isWrappable = true;\n  }\n\n  //Basically the handle collision function that will be run if there is a collision.\n  collideWith(otherObject) {\n    // default do nothing\n  }\n\n  //Since each object inherits from moving_object, they will all move a certain way\n  //that comes from this move method. They can all run the move method. This will come\n  //from the step method.\n  move(timeDelta, animationFrame) {\n    //timeDelta is number of milliseconds since last move\n    //if the computer is busy the time delta will be larger\n    //in this case the MovingObject should move farther in this frame\n    //velocity of object is how far it should move in 1/60th of a second\n\n    //We should normally move 60 frames in a second, so we are taking a time proportionality\n    //of the amount of time delta it took to reach this frame and multiplying by our nomal\n    //frame rate so we get movement that is proporitional.\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA,\n    offsetX = this.vel[0] * velocityScale,\n    offsetY = this.vel[1] * velocityScale;\n\n    this.pos = [this.pos[0] + offsetX, this.pos[1] + offsetY];\n    if ( this.type === \"enemy_ship\" && animationFrame % 80 === 0 )\n    {\n      this.vel = Util.scale([2*Math.random(),2*Math.random()], 1);\n    }\n    if (this.game.isOutOfBounds(this.pos)) {\n      if (this.isWrappable) {\n        this.pos = this.game.wrap(this.pos);\n      } else {\n        this.remove();\n      }\n    }\n  }\n  //MOVE AND THEN DRAW\n  //This draw method will help to draw a circle to the screen.\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n    //beginpath pretty much just lets us start the canvas drawing.\n    ctx.beginPath();\n    if ( this.type === \"player_ship\" )\n    {\n      this.grabImage();\n      ctx.drawImage(this.image, this.srx, this.sry, this.width, this.height, this.pos[0], this.pos[1], this.width, this.height);\n    }\n    if ( this.type === \"bullet\" )\n    {\n      ctx.drawImage(this.image, 449, 1270, this.width, this.height, this.pos[0], this.pos[1], this.width, this.height);\n    }\n    if ( this.type === \"enemy_ship\" )\n    {\n      ctx.drawImage(this.image, 530, 1998, this.width, this.height, this.pos[0], this.pos[1], this.width, this.height);\n    }\n    if ( this.type === \"enemy_bullet\" )\n    {\n      ctx.drawImage(this.image, 141, 1552, this.width, this.height, this.pos[0], this.pos[1], this.width, this.height);\n    }\n    // ctx.arc(\n    //   this.pos[0], this.pos[1], this.radius, 0, 2 * Math.PI, true\n    // );\n    ctx.fill();\n  }\n\n  //A better thing to do is to check for box collision since we won't be using circles.\n  isCollidedWith(otherObject) {\n    let x1 = this.pos[0];\n    let y1 = this.pos[1];\n    let w1 = this.width;\n    let h1 = this.height;\n    let x2 = otherObject.pos[0];\n    let y2 = otherObject.pos[1];\n    let w2 = otherObject.width;\n    let h2 = otherObject.height;\n    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 > y2 + h2 || y1 + h1 < y2);\n  }\n\n\n  remove() {\n    this.game.remove(this);\n  }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000/60;\n\nmodule.exports = MovingObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/moving_object.js\n// module id = 2\n// module chunks = 0","const Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = Game.DIM_X;\n  canvasEl.height = Game.DIM_Y;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  //lets initialize a new game\n  const game = new Game();\n  new GameView(game, ctx).start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tyranny.js\n// module id = 3\n// module chunks = 0","const Tyran = require(\"./tyran\");\nconst Bullet = require(\"./bullet\");\nconst Ship = require(\"./ship\");\nconst Util = require(\"./util\");\n// this contains all the objects in the game that we are going to change before we\n// re-render them all\n\nclass Game {\n  constructor() {\n    this.bullets = [];\n    this.ships = [];\n    this.enemies = [];\n    //lets add the enemies now\n    this.drawText = this.drawText.bind(this);\n    this.clearScreen = this.clearScreen.bind(this);\n    this.addEnemies();\n  }\n\n  add(object) {\n    if (object instanceof Bullet) {\n        this.bullets.push(object);\n    }\n    else if (object instanceof Tyran) {\n        this.enemies.push(object);\n    }\n    else if (object instanceof Ship) {\n        this.ships.push(object);\n    } else {\n      throw \"wtf?\";\n    }\n  }\n\n  addEnemies() {\n    var enemyImage = new Image();\n    enemyImage.src = \"assets/space.jpeg\";\n    for (let i = 0; i < Game.NUM_ENEMIES; i++) {\n      this.add(new Tyran({\n        game: this,\n        image: enemyImage,\n        type: \"enemy_ship\",\n        width: 60,\n        height: 46,\n      }));\n    }\n  }\n\n  addShip(shiptype) {\n    var shipImage = new Image();\n    shipImage.src = \"assets/space_forward.jpeg\";\n\n    const ship = new Ship({\n      pos: [500,500],\n      width: 53,\n      height: 46,\n      game: this,\n      image: shipImage,\n      type: shiptype\n    });\n\n    this.add(ship);\n\n    return ship;\n  }\n\n  allObjects() {\n    return [].concat(this.ships, this.bullets, this.enemies);\n  }\n\n  checkCollisions() {\n    const allObjects = this.allObjects();\n    for (let i = 0; i < allObjects.length; i++) {\n      for (let j = 0; j < allObjects.length; j++) {\n        const obj1 = allObjects[i];\n        const obj2 = allObjects[j];\n        //Everything depends on what type of object it is.\n        if (obj1.isCollidedWith(obj2)) {\n          //This is a way to end this early because their is only one collision per animation frame.\n          const collision = obj1.collideWith(obj2);\n          if (collision) return;\n        }\n      }\n    }\n  }\n\n  //THIS DOES ALL THE WORK OF MOVING ALL THE OBJECTS BEFORE THE NEXT RENDER\n  moveObjects(delta, animationFrame) {\n    this.allObjects().forEach((object) => {\n      object.move(delta, animationFrame);\n    });\n  }\n\n  drawText(text, ctx){\n    ctx.font = text.size + \" \" + text.font;\n    ctx.fillStyle = text.color;\n    ctx.fillText(\"Score:\" + \" \" + text.scorevalue + \"     \" + \"Lives:\" + \" \" + text.lifevalue, text.x, text.y);\n  }\n\n  clearScreen(ctx){\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n  }\n\n  drawGameOver(ctx){\n    this.clearScreen(ctx);\n    let finished ={\n      x: 220,\n      y: 250,\n      size: \"50px\",\n      font: \"PixelEmulator\",\n      color: \"red\"\n    }\n    ctx.font = finished.size + \" \" + finished.font;\n    ctx.fillStyle = finished.color;\n    ctx.fillText(\"GAME OVER YOU LOSE\", finished.x, finished.y);\n  }\n\n  //We use clear Rect and fillrect to draw over again\n  //lets draw up all of the objects on the screen again before we render them again.\n  draw(ctx) {\n    //canvas clear and fill rect will allow us to clear and re-render.\n    this.clearScreen(ctx);\n    this.drawText(this.ships[0].score, ctx);\n    // ctx.setTransform(0,1,1,0,1,1)\n    this.allObjects().forEach((object) => {\n      object.draw(ctx);\n    });\n  }\n\n  isOutOfBounds(pos) {\n    return (pos[0] < 0) || (pos[1] < 0) ||\n      (pos[0] > Game.DIM_X) || (pos[1] > Game.DIM_Y);\n  }\n  //Lets take all of our objects and move them based on how they should move and how far\n  //they should move\n\n  randomPosition() {\n    return [\n      Game.DIM_X * Math.random(),\n      ((Game.DIM_Y) / 2) * Math.random()\n    ];\n  }\n\n  remove(object) {\n    if (object instanceof Bullet) {\n      this.bullets.splice(this.bullets.indexOf(object), 1);\n    } else if (object instanceof Tyran) {\n      this.enemies.splice(this.enemies.indexOf(object), 1);\n    } else if (object instanceof Ship) {\n      this.ships.splice(this.ships.indexOf(object), 1);\n    } else {\n      throw \"wtf?\";\n    }\n  }\n  //Lets hand the animation, then the movement, then the physics to check for collisions.\n  step(delta, animationFrame) {\n    // this.animateObjects();\n    this.moveObjects(delta, animationFrame);\n    this.checkCollisions();\n  }\n\n  wrap(pos) {\n    return [\n      Util.wrap(pos[0], Game.DIM_X), Util.wrap(pos[1], Game.DIM_Y)\n    ];\n  }\n}\n\nGame.BG_COLOR = \"#000000\";\nGame.DIM_X = 1000;\nGame.DIM_Y = 550;\nGame.FPS = 32;\nGame.NUM_ENEMIES = 10;\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 4\n// module chunks = 0","const MovingObject = require(\"./moving_object\");\nconst Bullet = require(\"./bullet\");\nconst Util = require(\"./util\");\n\n\nfunction randomColor() {\n  const hexDigits = \"0123456789ABCDEF\";\n\n  let color = \"#\";\n  for (let i = 0; i < 3; i ++) {\n    color += hexDigits[Math.floor((Math.random() * 16))];\n  }\n\n  return color;\n}\n\nclass Ship extends MovingObject {\n  constructor(options) {\n    // start with velocity of 0\n    options.vel = options.vel || [0, 0];\n    options.color = options.color || randomColor();\n    options.image = options.image;\n    super(options);\n    this.score = {\n      scorevalue: 0,\n      lifevalue: 10,\n      x: 750,\n      y: 50,\n      size: \"25px\",\n      font: \"PixelEmulator\",\n      color: \"white\"\n    }\n    this.direction = \"flat\";\n    this.srx = 28;\n    this.sry = 2212;\n    this.flyingFrame = 0;\n    this.rightFrames = [[192,2255], [247, 2256], [303,2257], [521,2257]];\n    this.leftFrames = [[200,2208], [305, 2207], [416,2208], [523,2207]];\n    this.rightindex = -1;\n    this.leftindex = -1;\n    this.grabImage = this.grabImage.bind(this);\n  }\n\n  grabImage(){\n    let that = this;\n    if ( that.direction === \"right\" )\n    {\n      if (that.flyingFrame % 4 === 0){\n        that.rightindex += 1;\n        if ( that.rightindex >= that.rightFrames.length ){\n          return;\n        }\n        that.srx = that.rightFrames[that.rightindex][0];\n        that.sry = that.rightFrames[that.rightindex][1];\n      }\n      that.flyingFrame += 1;\n    }\n    else if (that.direction === \"left\")\n    {\n      if (that.flyingFrame % 4 === 0){\n        that.leftindex += 1;\n        if ( that.leftindex >= that.leftFrames.length )\n        {\n          return;\n        }\n        that.srx = that.leftFrames[that.leftindex][0];\n        that.sry = that.leftFrames[that.leftindex][1];\n      }\n      that.flyingFrame++;\n    }\n    // this.direction = \"flat\";\n  }\n\n  collideWith(otherObject) {\n    if (otherObject.type === \"enemy_bullet\") {\n      // otherObject.takeDamage();\n      this.score.lifevalue -= 1;\n      this.relocate();\n      otherObject.remove();\n          return true;\n    }\n  }\n\n  fireBullet() {\n    // const norm = Util.norm([0,this.vel[1]]);\n    //change this in your game because you will be able to fire even if you are moving\n    // if (norm == 0) {\n    //   // Can't fire unless moving.\n    //   return;\n    // }\n    //GET THE RELATIVE VELOCITY TO THE SHIP FROM THE DIRECTION AND THE SPEED\n    const relVel = Util.scale(\n      Util.dir([0, -1]),\n      Bullet.SPEED\n    );\n\n    const bulletVel = [\n      0, relVel[1] + this.vel[1]\n    ];\n    //MOVE THIS\n    var bullet_image = new Image();\n    bullet_image.src = \"assets/space.jpeg\";\n\n    const bullet = new Bullet({\n      pos: [this.pos[0] + 10, this.pos[1] - 63],\n      width: 21,\n      height: 77,\n      vel: bulletVel,\n      color: this.color,\n      game: this.game,\n      type: \"bullet\",\n      image: bullet_image\n    });\n\n    this.game.add(bullet);\n  }\n//Power and then move the object\n  power(impulse) {\n    this.vel[0] += impulse[0];\n    this.vel[1] += impulse[1];\n  }\n\n  relocate() {\n    this.pos = this.game.randomPosition();\n    this.vel = [0, 0];\n  }\n}\n\nmodule.exports = Ship;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/ship.js\n// module id = 5\n// module chunks = 0","//This contains all the logic for rendering the game\nclass GameView {\n  constructor(game, ctx) {\n    this.ctx = ctx;\n    this.game = game;\n    this.animationFrame = 0;\n    //We add the ship as soon as the game starts.\n    this.ship = this.game.addShip(\"player_ship\");\n  }\n  //Lets bind the key handlers that are going to let us handle input from the user.\n  bindKeyHandlers() {\n    const ship = this.ship;\n    let that = this;\n    Object.keys(GameView.MOVES).forEach((k) => {\n      let move = GameView.MOVES[k];\n      key(k, () => {\n        // console.log(key.isPressed(k));\n        ship.direction = k;\n        ship.power(move); });\n    });\n    key(\"space\", () => { ship.fireBullet() });\n  }\n\n  start() {\n    this.bindKeyHandlers();\n    this.lastTime = 0;\n    //start the animation\n    requestAnimationFrame(this.animate.bind(this));\n  }\n  //This is doing a lot of things. It is determining all the new positions, checking for collisions.\n  //Come back here when you are thinking about what is going on.\n  //this is a recursive call contantly being made\n\n  //animate refers to animating the entire game here.\n  animate(time) {\n    const timeDelta = time - this.lastTime;\n    if ( key.getPressedKeyCodes().length === 0 )\n    {\n      this.ship.srx = 28;\n      this.ship.sry = 2212;\n      this.ship.direction = \"flat\";\n      this.ship.flyingFrame = 0;\n      this.ship.rightindex = -1;\n      this.ship.leftindex = -1;\n      this.ship.vel = [0,0];\n    }\n\n    if ( this.animationFrame % 200 === 0 )\n    {\n      this.game.enemies.forEach((enemy) => {\n        enemy.fireBullet();\n      })\n    }\n    this.game.step(timeDelta, this.animationFrame);\n    this.game.draw(this.ctx);\n    //lets reset the time.\n    this.lastTime = time;\n    this.animationFrame++;\n    if ( this.game.ships[0].score.lifevalue === 0 )\n    {\n      this.game.drawGameOver(this.ctx);\n      return;\n    }\n    //every call to animate requests causes another call to animate\n    //repetitive callback\n    requestAnimationFrame(this.animate.bind(this));\n  }\n}\n\nGameView.MOVES = {\n  \"up\": [ 0, -1],\n  \"left\": [-1,  0],\n  \"down\": [ 0,  1],\n  \"right\": [ 1,  0]\n};\n\nmodule.exports = GameView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game_view.js\n// module id = 6\n// module chunks = 0","const Util = require(\"./util\");\nconst MovingObject = require(\"./moving_object\");\nconst Ship = require(\"./ship\");\nconst Bullet = require(\"./bullet\");\n\nconst DEFAULTS = {\n\tSPEED: 1\n};\n\nclass Tyran extends MovingObject {\n    constructor(options = {}) {\n      options.game = options.game;\n      options.width = options.width;\n      options.height = options.height;\n      options.pos = options.pos || options.game.randomPosition();\n      options.vel = options.vel || Util.scale([2*Math.random(),2*Math.random()], DEFAULTS.SPEED);\n\t\t\tsuper(options);\n    }\n    //Make the logic for getting hurt by bullets here.\n    //Our ship is currently just relocating when it gets hit\n    collideWith(otherObject) {\n      if (otherObject instanceof Ship) {\n        // otherObject.takeDamage();\n        otherObject.score.lifevalue -= 1;\n        otherObject.relocate();\n            return true;\n      } else if (otherObject.type === \"bullet\") {\n            this.game.ships[0].score.scorevalue += 100;\n            this.remove();\n            otherObject.remove();\n            return true;\n        }\n    }\n\n    fireBullet() {\n      // const norm = Util.norm([0,this.vel[1]]);\n      //change this in your game because you will be able to fire even if you are moving\n      // if (norm == 0) {\n      //   // Can't fire unless moving.\n      //   return;\n      // }\n      //GET THE RELATIVE VELOCITY TO THE SHIP FROM THE DIRECTION AND THE SPEED\n      const relVel = Util.scale(\n        Util.dir([0, 1]),\n        2\n      );\n\n      const bulletVel = [\n        0, relVel[1] + this.vel[1]\n      ];\n      //MOVE THIS\n      var enemy_bullet_image = new Image();\n      enemy_bullet_image.src = \"assets/space.jpeg\";\n\n      const bullet = new Bullet({\n        pos: [this.pos[0] + 14, this.pos[1] + 40],\n        width: 27,\n        height: 69,\n        vel: bulletVel,\n        color: this.color,\n        game: this.game,\n        type: \"enemy_bullet\",\n        image: enemy_bullet_image\n      });\n      //You want the game to have knowledge of this bullet\n      this.game.add(bullet);\n    }\n}\n\nmodule.exports = Tyran;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tyran.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}